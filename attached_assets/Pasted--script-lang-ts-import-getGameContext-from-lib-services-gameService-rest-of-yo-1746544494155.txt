<script lang="ts">
  import { getGameContext } from '$lib/services/gameService';
  // … rest of your imports …

  /** 
   * Replaces your old `loadCardData`/`loadAgreementData`/`loadGameData`
   * with one single call to getGameContext.
   */
  async function loadGameData(): Promise<{
    cards: CardWithPosition[];
    agreements: AgreementWithPosition[];
    actors: ActorWithCard[];
  }> {
    const ctx = await getGameContext(gameId);
    if (!ctx) {
      return { cards: [], agreements: [], actors: [] };
    }

    // 1️⃣ extract all assigned cards (with their actor_id & position baked in)
    const assigned: CardWithPosition[] = ctx.actors
      .filter(a => !!a.card)
      .map(a => ({
        ...a.card!,
        actor_id: a.actor_id,
        position: a.position!,
        // preserve any precomputed names if you chose to attach them in getGameContext
        _valueNames:   a.card!._valueNames   ?? [],
        _capabilityNames: a.card!._capabilityNames ?? []
      }));

    // 2️⃣ append the “available” cards
    const allCards = [ ...assigned, ...ctx.availableCards ];

    return {
      cards: allCards,
      agreements: ctx.agreements,
      actors: ctx.actors
    };
  }

  /** 
   * One function that replaces your entire old initializeVisualization 
   * + subscription logic — it pulls everything in one go and then
   * boots D3.
   */
  async function initializeVisualization() {
    if (!svgElement) return;
    // load everything in parallel
    const { cards, agreements: loadedAgreements, actors: loadedActors } = await loadGameData();

    cardsWithPosition = cards;
    agreements         = loadedAgreements;
    actors             = loadedActors;

    // build the map from actor → card
    actorCardMap.clear();
    actors.forEach(a => a.card && actorCardMap.set(a.actor_id, a.card.card_id));

    // now invoke your existing D3 setup
    const graphState = initializeD3Graph(
      svgElement,
      cardsWithPosition,
      agreements,
      width,
      height,
      activeCardId,
      (node) => selectedNode = node,
      actorCardMap
    );
    simulation  = graphState.simulation;
    nodeElements = graphState.nodeElements;

    // add donut rings, icons, etc. exactly as before…
    addDonutRings(nodeElements, activeCardId);
    const iconNames = cardsWithPosition.map(c => c.icon).filter((v,i,a)=>v && a.indexOf(v)===i);
    await loadIcons(iconNames);
    nodeElements.each(function(node) {
      if (node.type === 'actor') {
        createCardIcon(node.data.icon||'user', node.id===activeCardId?36:24, this as any, node.data.role_title);
      }
    });

    // subscribe only once — on any change we just re-run initializeVisualization()
    unsubscribe.push(
      subscribeToGame(gameId, () => {
        // you might throttle or diff here, but simplest is to reload
        initializeVisualization();
      })
    );
  }

  // mount + cleanup
  $effect(() => {
    initializeVisualization();
    return () => {
      simulation?.stop();
      unsubscribe.forEach(u => u());
    };
  });
</script>
